<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Learn the Offside Rule ‚Äî Linesman Training</title>
    <style>
      :root {
        --green-dark: #1b5e20;
        --green-mid: #2e7d32;
        --green-light: #4caf50;
        --green-pitch: #388e3c;
        --green-grass: #43a047;
        --white: #ffffff;
        --off-white: #f5f5f5;
        --yellow: #fdd835;
        --red: #e53935;
        --blue-team: #1565c0;
        --red-team: #c62828;
        --grey: #616161;
        --dark: #212121;
        --shadow: rgba(0, 0, 0, 0.18);
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family:
          "Segoe UI",
          system-ui,
          -apple-system,
          sans-serif;
        background: var(--off-white);
        color: var(--dark);
        line-height: 1.6;
      }

      /* Header */
      header {
        background: linear-gradient(
          135deg,
          var(--green-dark),
          var(--green-mid)
        );
        color: var(--white);
        text-align: center;
        padding: 2rem 1rem;
        box-shadow: 0 4px 12px var(--shadow);
      }
      header h1 {
        font-size: 2rem;
        margin-bottom: 0.25rem;
      }
      header p {
        opacity: 0.9;
        font-size: 1.05rem;
        max-width: 600px;
        margin: 0 auto;
      }

      /* Nav Tabs */
      nav {
        display: flex;
        justify-content: center;
        gap: 0;
        background: var(--green-mid);
        flex-wrap: wrap;
      }
      nav button {
        background: transparent;
        color: rgba(255, 255, 255, 0.75);
        border: none;
        padding: 0.85rem 1.5rem;
        font-size: 0.95rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
        border-bottom: 3px solid transparent;
      }
      nav button:hover {
        color: var(--white);
        background: rgba(255, 255, 255, 0.08);
      }
      nav button.active {
        color: var(--white);
        border-bottom-color: var(--yellow);
        background: rgba(255, 255, 255, 0.1);
      }

      /* Sections */
      .section {
        display: none;
        max-width: 900px;
        margin: 0 auto;
        padding: 2rem 1.25rem 4rem;
      }
      .section.active {
        display: block;
      }

      h2 {
        color: var(--green-dark);
        font-size: 1.55rem;
        margin-bottom: 1rem;
      }
      h3 {
        color: var(--green-mid);
        margin: 1.5rem 0 0.5rem;
        font-size: 1.15rem;
      }

      p,
      li {
        margin-bottom: 0.5rem;
      }
      ul {
        padding-left: 1.25rem;
      }

      .card {
        background: var(--white);
        border-radius: 12px;
        padding: 1.5rem;
        margin-bottom: 1.25rem;
        box-shadow: 0 2px 8px var(--shadow);
      }
      .card h3 {
        margin-top: 0;
      }

      .highlight-box {
        background: linear-gradient(135deg, #e8f5e9, #c8e6c9);
        border-left: 4px solid var(--green-light);
        border-radius: 0 8px 8px 0;
        padding: 1rem 1.25rem;
        margin: 1rem 0;
      }
      .warning-box {
        background: #fff3e0;
        border-left: 4px solid #ff9800;
        border-radius: 0 8px 8px 0;
        padding: 1rem 1.25rem;
        margin: 1rem 0;
      }

      /* Pitch Canvas */

      /* Scenario controls */
      .scenario-controls {
        text-align: center;
        margin: 1.25rem 0;
        display: flex;
        justify-content: center;
        gap: 0.75rem;
        flex-wrap: wrap;
      }

      button.btn {
        padding: 0.7rem 1.6rem;
        border: none;
        border-radius: 8px;
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
      }
      button.btn-primary {
        background: var(--green-light);
        color: var(--white);
      }
      button.btn-primary:hover {
        background: var(--green-dark);
      }
      button.btn-outline {
        background: transparent;
        color: var(--green-mid);
        border: 2px solid var(--green-mid);
      }
      button.btn-outline:hover {
        background: var(--green-mid);
        color: var(--white);
      }
      button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .explanation-text {
        max-width: 700px;
        margin: 0.5rem auto;
        padding: 0.75rem 1rem;
        background: #e3f2fd;
        border-radius: 8px;
        display: none;
        line-height: 1.5;
      }
      .explanation-text.show {
        display: block;
      }

      .score-bar {
        display: flex;
        justify-content: center;
        gap: 2rem;
        margin: 1rem 0;
        font-size: 1.1rem;
        font-weight: 600;
      }
      .score-bar span {
        padding: 0.4rem 1rem;
        border-radius: 6px;
      }
      .score-correct {
        background: #c8e6c9;
        color: #1b5e20;
      }
      .score-wrong {
        background: #ffcdd2;
        color: #b71c1c;
      }
      .score-total {
        background: #e3f2fd;
        color: #1565c0;
      }

      /* Quiz */
      .quiz-option {
        display: block;
        width: 100%;
        text-align: left;
        padding: 0.85rem 1.1rem;
        margin-bottom: 0.5rem;
        border: 2px solid #e0e0e0;
        border-radius: 8px;
        background: var(--white);
        font-size: 0.95rem;
        cursor: pointer;
        transition: all 0.15s;
      }
      .quiz-option:hover {
        border-color: var(--green-light);
        background: #f1f8e9;
      }
      .quiz-option.selected {
        border-color: var(--green-light);
        background: #e8f5e9;
      }
      .quiz-option.correct-answer {
        border-color: var(--green-light);
        background: #c8e6c9;
      }
      .quiz-option.wrong-answer {
        border-color: var(--red);
        background: #ffcdd2;
      }
      .quiz-option:disabled {
        cursor: default;
      }

      /* Progress bar */
      .progress-bar-container {
        width: 100%;
        max-width: 700px;
        margin: 1rem auto;
        background: #e0e0e0;
        border-radius: 10px;
        height: 10px;
        overflow: hidden;
      }
      .progress-bar-fill {
        height: 100%;
        background: linear-gradient(90deg, var(--green-light), var(--yellow));
        border-radius: 10px;
        transition: width 0.4s ease;
      }

      /* Key diagram */
      .key-row {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        margin: 0.35rem 0;
        font-size: 0.9rem;
      }
      .key-dot {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        flex-shrink: 0;
        border: 2px solid rgba(0, 0, 0, 0.2);
      }
      .key-line {
        width: 30px;
        height: 3px;
        flex-shrink: 0;
      }

      /* Tips list */
      .tip-number {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 28px;
        height: 28px;
        background: var(--green-light);
        color: var(--white);
        border-radius: 50%;
        font-weight: 700;
        font-size: 0.85rem;
        margin-right: 0.5rem;
        flex-shrink: 0;
      }
      .tip-item {
        display: flex;
        align-items: flex-start;
        margin-bottom: 1rem;
      }

      .emoji {
        font-size: 1.3rem;
        margin-right: 0.5rem;
      }

      /* 3D Mode */
      #scene3d-container {
        position: relative;
        width: 100%;
        max-width: 900px;
        margin: 1rem auto;
        border-radius: 12px;
        overflow: hidden;
        box-shadow: 0 6px 24px rgba(0, 0, 0, 0.3);
        background: #111;
      }
      #scene3d-container canvas {
        display: block;
        width: 100% !important;
        height: auto !important;
      }
      .hud-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        padding: 12px 16px;
        pointer-events: none;
        z-index: 10;
      }
      .hud-box {
        background: rgba(0, 0, 0, 0.65);
        backdrop-filter: blur(6px);
        color: #fff;
        padding: 8px 14px;
        border-radius: 8px;
        font-size: 0.85rem;
        font-weight: 600;
        pointer-events: auto;
      }
      .hud-box .label {
        opacity: 0.7;
        font-size: 0.75rem;
        display: block;
      }
      .hud-timer {
        font-size: 1.4rem;
        font-variant-numeric: tabular-nums;
      }
      .hud-streak {
        color: #fdd835;
      }
      .camera-controls {
        display: flex;
        justify-content: center;
        gap: 0.5rem;
        margin: 0.75rem 0;
        flex-wrap: wrap;
      }
      .cam-btn {
        padding: 0.45rem 1rem;
        border: 2px solid var(--green-mid);
        background: transparent;
        color: var(--green-mid);
        border-radius: 6px;
        font-size: 0.82rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.15s;
      }
      .cam-btn:hover,
      .cam-btn.active {
        background: var(--green-mid);
        color: #fff;
      }
      .freeze-banner {
        position: absolute;
        bottom: 60px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.8);
        color: #fdd835;
        padding: 10px 28px;
        border-radius: 10px;
        font-size: 1.1rem;
        font-weight: 700;
        text-align: center;
        z-index: 20;
        display: none;
        animation: pulseIn 0.3s ease;
        white-space: nowrap;
      }
      @keyframes pulseIn {
        0% {
          transform: translateX(-50%) scale(0.8);
          opacity: 0;
        }
        100% {
          transform: translateX(-50%) scale(1);
          opacity: 1;
        }
      }
      .decision-buttons {
        position: absolute;
        bottom: 12px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 12px;
        z-index: 20;
      }
      .decision-buttons button {
        padding: 10px 28px;
        border: none;
        border-radius: 10px;
        font-size: 1rem;
        font-weight: 700;
        cursor: pointer;
        transition: all 0.15s;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      }
      .decision-buttons .btn-3d-offside {
        background: linear-gradient(135deg, #e53935, #b71c1c);
        color: #fff;
      }
      .decision-buttons .btn-3d-offside:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 16px rgba(229, 57, 53, 0.4);
      }
      .decision-buttons .btn-3d-onside {
        background: linear-gradient(135deg, #43a047, #1b5e20);
        color: #fff;
      }
      .decision-buttons .btn-3d-onside:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 16px rgba(67, 160, 71, 0.4);
      }
      .decision-buttons button:disabled {
        opacity: 0.4;
        cursor: not-allowed;
        transform: none;
      }

      .result-3d {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 25;
        text-align: center;
        display: none;
      }
      .result-3d .verdict {
        font-size: 2.2rem;
        font-weight: 900;
        text-shadow: 0 4px 16px rgba(0, 0, 0, 0.5);
        margin-bottom: 8px;
      }
      .result-3d .sub {
        font-size: 1rem;
        background: rgba(0, 0, 0, 0.7);
        color: #fff;
        padding: 10px 20px;
        border-radius: 8px;
        max-width: 420px;
        line-height: 1.4;
      }
      .result-3d.correct .verdict {
        color: #69f0ae;
      }
      .result-3d.wrong .verdict {
        color: #ff5252;
      }
      .result-3d.show {
        display: block;
      }

      .replay-bar {
        display: flex;
        justify-content: center;
        gap: 0.75rem;
        margin-top: 0.5rem;
      }

      /* Timeline / Playback Controls */
      .timeline-bar {
        background: rgba(0, 0, 0, 0.75);
        backdrop-filter: blur(6px);
        padding: 10px 16px 8px;
        border-radius: 0 0 12px 12px;
        max-width: 900px;
        margin: 0 auto;
      }
      .timeline-row {
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .timeline-slider-wrap {
        flex: 1;
        position: relative;
        height: 28px;
        display: flex;
        align-items: center;
      }
      .timeline-slider {
        -webkit-appearance: none;
        appearance: none;
        width: 100%;
        height: 6px;
        border-radius: 3px;
        background: linear-gradient(
          90deg,
          #4caf50 0%,
          #4caf50 var(--fill, 0%),
          #555 var(--fill, 0%),
          #555 100%
        );
        outline: none;
        cursor: pointer;
        position: relative;
        z-index: 2;
      }
      .timeline-slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: #fff;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.4);
        cursor: grab;
        border: 2px solid #4caf50;
        transition: transform 0.1s;
      }
      .timeline-slider::-webkit-slider-thumb:hover {
        transform: scale(1.2);
      }
      .timeline-slider::-moz-range-thumb {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: #fff;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.4);
        cursor: grab;
        border: 2px solid #4caf50;
      }
      .timeline-slider:active::-webkit-slider-thumb {
        cursor: grabbing;
        transform: scale(1.3);
      }
      .kick-marker {
        position: absolute;
        height: 16px;
        width: 3px;
        background: #fdd835;
        border-radius: 2px;
        top: 50%;
        transform: translateY(-50%);
        z-index: 1;
        pointer-events: none;
      }
      .kick-marker::after {
        content: "‚ö° PASS";
        position: absolute;
        top: -18px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 0.62rem;
        color: #fdd835;
        font-weight: 700;
        white-space: nowrap;
      }
      .timeline-time {
        color: #ccc;
        font-size: 0.78rem;
        font-variant-numeric: tabular-nums;
        min-width: 42px;
        text-align: center;
        font-weight: 600;
      }
      .playback-controls {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
        margin-top: 6px;
      }
      .pb-btn {
        background: rgba(255, 255, 255, 0.12);
        border: none;
        color: #fff;
        width: 34px;
        height: 34px;
        border-radius: 50%;
        font-size: 1rem;
        cursor: pointer;
        transition: all 0.15s;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .pb-btn:hover {
        background: rgba(255, 255, 255, 0.25);
      }
      .pb-btn.active {
        background: rgba(76, 175, 80, 0.4);
        color: #69f0ae;
      }
      .pb-btn-play {
        width: 42px;
        height: 42px;
        font-size: 1.2rem;
        background: rgba(76, 175, 80, 0.3);
      }
      .pb-btn-play:hover {
        background: rgba(76, 175, 80, 0.5);
      }
      .speed-label {
        color: #aaa;
        font-size: 0.72rem;
        font-weight: 600;
        min-width: 32px;
        text-align: center;
      }
      .timeline-phase {
        color: #fdd835;
        font-size: 0.75rem;
        font-weight: 700;
        text-align: center;
        margin-top: 2px;
        height: 16px;
      }

      @media (max-width: 600px) {
        header h1 {
          font-size: 1.5rem;
        }
        nav button {
          padding: 0.65rem 0.9rem;
          font-size: 0.82rem;
        }
        .section {
          padding: 1.25rem 1rem 3rem;
        }
        .freeze-banner {
          font-size: 0.9rem;
          padding: 8px 16px;
        }
        .decision-buttons button {
          padding: 8px 18px;
          font-size: 0.9rem;
        }
        .result-3d .verdict {
          font-size: 1.6rem;
        }
        .pb-btn {
          width: 30px;
          height: 30px;
          font-size: 0.85rem;
        }
        .pb-btn-play {
          width: 36px;
          height: 36px;
        }
        .timeline-bar {
          padding: 8px 10px 6px;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h1>‚öΩ The Offside Rule</h1>
      <p>
        A quick interactive guide for parents running the line at kids' matches
      </p>
    </header>

    <nav id="mainNav">
      <button class="active" data-tab="learn">üìñ Learn</button>
      <button data-tab="3d">üèüÔ∏è Interactive</button>
      <button data-tab="quiz">üìù Quiz</button>
      <button data-tab="tips">üí° Matchday Tips</button>
    </nav>

    <!-- ==================== LEARN ==================== -->
    <section class="section active" id="sec-learn">
      <h2>What Is Offside?</h2>

      <div class="card">
        <h3>The Basic Rule</h3>
        <p>
          A player is in an <strong>offside position</strong> if, at the moment
          the ball is played by a team-mate:
        </p>
        <ul>
          <li>They are in the <strong>opponent's half</strong> of the pitch</li>
          <li>
            They are <strong>closer to the opponent's goal line</strong> than
            both the ball <em>and</em> the
            <strong>second-last defender</strong> (the goalkeeper is usually the
            last)
          </li>
        </ul>
        <div class="highlight-box">
          <strong>Key phrase to remember:</strong> "Behind the second-last
          defender, in the opponents' half, when the ball is played."
        </div>
      </div>

      <div class="card">
        <h3>When Is It Actually an Offence?</h3>
        <p>
          Being in an offside <em>position</em> alone is <strong>not</strong> an
          offence. It only becomes one if, at the moment the ball is played by a
          team-mate, the player in an offside position:
        </p>
        <ul>
          <li>
            <strong>Interferes with play</strong> ‚Äî touches or plays the ball
          </li>
          <li>
            <strong>Interferes with an opponent</strong> ‚Äî obstructs their line
            of vision, challenges them, or clearly impacts their ability to play
            the ball
          </li>
          <li>
            <strong>Gains an advantage</strong> ‚Äî plays a ball that rebounds off
            the post, crossbar, or a defender having been in an offside position
          </li>
        </ul>
      </div>

      <div class="card">
        <h3>When Is It NOT Offside?</h3>
        <ul>
          <li>Receiving the ball directly from a <strong>goal kick</strong></li>
          <li>Receiving the ball directly from a <strong>throw-in</strong></li>
          <li>
            Receiving the ball directly from a <strong>corner kick</strong>
          </li>
          <li>The player is in their <strong>own half</strong> of the pitch</li>
          <li>
            The player is <strong>level with</strong> the second-last defender
            (level is onside!)
          </li>
          <li>
            The player is <strong>behind the ball</strong> when it is played
          </li>
        </ul>
        <div class="warning-box">
          <strong>Common mistake:</strong> Many parents forget that offside does
          NOT apply at throw-ins, goal kicks, or corners. Keep this in mind!
        </div>
      </div>

      <div class="card">
        <h3>Body Parts That Count</h3>
        <p>
          Only parts of the body that can
          <strong>legitimately play the ball</strong> are considered ‚Äî head,
          body, and feet. <strong>Arms and hands do not count</strong> (just as
          for any outfield player). So if a player's arm is past the defender
          but their body isn't, they're onside.
        </p>
      </div>

      <div class="card">
        <h3>Understanding the Diagram Key</h3>
        <div class="key-row">
          <div class="key-dot" style="background: #1565c0"></div>
          Attacking team (blue)
        </div>
        <div class="key-row">
          <div class="key-dot" style="background: #c62828"></div>
          Defending team (red)
        </div>
        <div class="key-row">
          <div class="key-dot" style="background: #ff9800"></div>
          Goalkeeper
        </div>
        <div class="key-row">
          <div
            class="key-dot"
            style="background: #fdd835; border-color: #888"
          ></div>
          Ball
        </div>
        <div class="key-row">
          <div
            class="key-dot"
            style="background: #1565c0; border: 3px solid #fdd835"
          ></div>
          Attacker in question (yellow ring)
        </div>
        <div class="key-row">
          <div class="key-line" style="background: #e53935"></div>
          Offside line (second-last defender)
        </div>
      </div>
    </section>

    <!-- ==================== 3D INTERACTIVE ==================== -->
    <section class="section" id="sec-3d">
      <h2>üèüÔ∏è Interactive Scenarios</h2>
      <p>
        Watch the play unfold in 3D from the linesman's view. When the pass is
        made, the action <strong>freezes</strong> ‚Äî make your call!
      </p>

      <div class="score-bar">
        <span class="score-correct" id="t3Correct">‚úì 0</span>
        <span class="score-wrong" id="t3Wrong">‚úó 0</span>
        <span class="score-total" id="t3Total">0 / 0</span>
      </div>
      <div class="progress-bar-container">
        <div class="progress-bar-fill" id="t3Progress" style="width: 0%"></div>
      </div>

      <div class="camera-controls">
        <button
          class="cam-btn active"
          onclick="setCamera('linesman')"
          id="camLinesman"
        >
          üö© Linesman View
        </button>
        <button
          class="cam-btn"
          onclick="setCamera('broadcast')"
          id="camBroadcast"
        >
          üì∫ Broadcast
        </button>
        <button class="cam-btn" onclick="setCamera('topdown')" id="camTopdown">
          üîΩ Top Down
        </button>
        <button
          class="cam-btn"
          onclick="setCamera('behindgoal')"
          id="camBehindgoal"
        >
          ü•Ö Behind Goal
        </button>
      </div>

      <div id="scene3d-container">
        <div class="hud-overlay">
          <div class="hud-box">
            <span class="label">SCENARIO</span>
            <span id="hud-scenario">1 / 8</span>
          </div>
          <div class="hud-box">
            <span class="label">STREAK</span>
            <span class="hud-streak" id="hud-streak">üî• 0</span>
          </div>
        </div>
        <div class="freeze-banner" id="freezeBanner">
          ‚è∏Ô∏è FREEZE! Make your call ‚Äî Offside or Onside?
        </div>
        <div
          class="decision-buttons"
          id="decisionButtons"
          style="display: none"
        >
          <button
            class="btn-3d-offside"
            id="btn3dOffside"
            onclick="submit3DAnswer(true)"
          >
            üö© OFFSIDE
          </button>
          <button
            class="btn-3d-onside"
            id="btn3dOnside"
            onclick="submit3DAnswer(false)"
          >
            ‚úÖ ONSIDE
          </button>
        </div>
        <div class="result-3d" id="result3d">
          <div class="verdict" id="result3dVerdict"></div>
          <div class="sub" id="result3dSub"></div>
        </div>
      </div>

      <!-- Timeline & Playback Controls -->
      <div class="timeline-bar" id="timelineBar">
        <div class="timeline-row">
          <span class="timeline-time" id="timelineCurrent">0.0s</span>
          <div class="timeline-slider-wrap">
            <input
              type="range"
              class="timeline-slider"
              id="timelineSlider"
              min="0"
              max="1000"
              value="0"
              step="1"
            />
            <div class="kick-marker" id="kickMarker" style="left: 50%"></div>
          </div>
          <span class="timeline-time" id="timelineTotal">2.2s</span>
        </div>
        <div class="playback-controls">
          <button class="pb-btn" onclick="stepFrame(-0.15)" title="Step Back">
            ‚è™
          </button>
          <button class="pb-btn" onclick="stepFrame(-0.05)" title="Nudge Back">
            ‚óÄ
          </button>
          <button
            class="pb-btn pb-btn-play"
            id="btnPlayPause"
            onclick="togglePlayPause()"
            title="Play / Pause"
          >
            ‚è∏
          </button>
          <button
            class="pb-btn"
            onclick="stepFrame(0.05)"
            title="Nudge Forward"
          >
            ‚ñ∂
          </button>
          <button class="pb-btn" onclick="stepFrame(0.15)" title="Step Forward">
            ‚è©
          </button>
          <span style="width: 12px"></span>
          <button
            class="pb-btn"
            id="btnSpeed"
            onclick="cycleSpeed()"
            title="Playback Speed"
          >
            1√ó
          </button>
          <span style="width: 8px"></span>
          <button class="pb-btn" onclick="replay3DScenario()" title="Replay">
            üîÑ
          </button>
          <button
            class="pb-btn"
            id="btnShowLine"
            onclick="toggleOffsideLine()"
            title="Toggle Offside Line"
          >
            üìè
          </button>
        </div>
        <div class="timeline-phase" id="timelinePhase">‚ñ∂ Build-up</div>
      </div>

      <div class="explanation-text" id="explanation3d"></div>

      <div class="replay-bar">
        <button
          class="btn btn-primary"
          id="btn3dNext"
          onclick="next3DScenario()"
          style="display: none"
        >
          Next Scenario ‚Üí
        </button>
        <button
          class="btn btn-outline"
          id="btn3dRestart"
          onclick="restart3D()"
          style="display: none"
        >
          üèÜ Start Over
        </button>
      </div>
    </section>

    <!-- ==================== QUIZ ==================== -->
    <section class="section" id="sec-quiz">
      <h2>Knowledge Quiz</h2>
      <p>Test your understanding of the offside rule with these questions.</p>

      <div class="score-bar">
        <span class="score-correct" id="qCorrect">‚úì 0</span>
        <span class="score-wrong" id="qWrong">‚úó 0</span>
        <span class="score-total" id="qTotal">0 / 0</span>
      </div>

      <div class="progress-bar-container">
        <div class="progress-bar-fill" id="qProgress" style="width: 0%"></div>
      </div>

      <div class="card" id="quizCard">
        <h3 id="quizQuestion"></h3>
        <div id="quizOptions"></div>
      </div>

      <div class="explanation-text" id="quizExplanation"></div>

      <div class="scenario-controls">
        <button
          class="btn btn-primary"
          id="btnQuizNext"
          onclick="nextQuizQuestion()"
          style="display: none"
        >
          Next Question ‚Üí
        </button>
        <button
          class="btn btn-outline"
          id="btnQuizReset"
          onclick="resetQuiz()"
          style="display: none"
        >
          üîÑ Start Over
        </button>
      </div>
    </section>

    <!-- ==================== TIPS ==================== -->
    <section class="section" id="sec-tips">
      <h2>Matchday Tips for Parent Linesmen</h2>

      <div class="card">
        <h3>üèÉ Positioning</h3>
        <div class="tip-item">
          <span class="tip-number">1</span
          ><span
            >Stay <strong>in line with the second-last defender</strong> at all
            times. This is your most important job ‚Äî if you're out of position,
            you can't make the call.</span
          >
        </div>
        <div class="tip-item">
          <span class="tip-number">2</span
          ><span
            >Move up and down the touchline, keeping pace with play. Watch the
            defenders, not just the ball.</span
          >
        </div>
        <div class="tip-item">
          <span class="tip-number">3</span
          ><span
            >Stand side-on so you can see both the ball and the defensive line
            in your peripheral vision.</span
          >
        </div>
      </div>

      <div class="card">
        <h3>üëÄ What to Watch</h3>
        <div class="tip-item">
          <span class="tip-number">4</span
          ><span
            ><strong>Watch the moment the ball is kicked</strong>, not where it
            ends up. Offside is judged at the instant of the pass, not when the
            ball arrives.</span
          >
        </div>
        <div class="tip-item">
          <span class="tip-number">5</span
          ><span
            >Focus on the defensive line and the attacker's position relative to
            it. Use a "mental snapshot" at the moment of the pass.</span
          >
        </div>
        <div class="tip-item">
          <span class="tip-number">6</span
          ><span
            >For kids' football, don't worry about getting it perfect. Do your
            best ‚Äî even professional assistants get help from VAR!</span
          >
        </div>
      </div>

      <div class="card">
        <h3>üö© Flag Technique</h3>
        <div class="tip-item">
          <span class="tip-number">7</span
          ><span
            >Hold the flag in the hand
            <strong>nearest the referee</strong> (switch hands at half-time when
            you change ends).</span
          >
        </div>
        <div class="tip-item">
          <span class="tip-number">8</span
          ><span
            >For offside: <strong>raise the flag straight up</strong>, wait for
            the referee's whistle, then point to where the offence occurred
            (near side, centre, or far side).</span
          >
        </div>
        <div class="tip-item">
          <span class="tip-number">9</span
          ><span
            >Keep the flag <strong>unfurled and visible</strong>. Don't let it
            wrap around the stick.</span
          >
        </div>
      </div>

      <div class="card">
        <h3>‚öñÔ∏è When in Doubt</h3>
        <div class="tip-item">
          <span class="tip-number">10</span
          ><span
            ><strong>If in doubt, keep your flag down.</strong> "Benefit of the
            doubt to the attacker" is the standard approach. It's far better to
            miss a marginal offside than to wrongly flag a goal-scoring
            chance.</span
          >
        </div>
        <div class="tip-item">
          <span class="tip-number">11</span
          ><span
            >Remember: the referee can overrule you. They have the final say.
            Don't argue ‚Äî just carry on.</span
          >
        </div>
        <div class="tip-item">
          <span class="tip-number">12</span
          ><span
            >Stay calm. Parents on the other side may disagree ‚Äî that's part of
            the job! A friendly smile goes a long way.</span
          >
        </div>
      </div>

      <div class="card">
        <h3>üìã Quick Reminders</h3>
        <div class="highlight-box">
          <strong>NOT offside from:</strong> Throw-ins, goal kicks, and corner
          kicks. If the ball comes directly from one of these, you cannot be
          offside.
        </div>
        <div class="highlight-box">
          <strong>Level is onside:</strong> If the attacker is exactly level
          with the second-last defender, they are ONSIDE.
        </div>
        <div class="highlight-box">
          <strong>Own half = safe:</strong> A player in their own half of the
          pitch cannot be offside, no matter where the defenders are.
        </div>
      </div>
    </section>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
      // ==================== TAB NAVIGATION ====================
      const navBtns = document.querySelectorAll("nav button");
      navBtns.forEach((btn) => {
        btn.addEventListener("click", () => {
          navBtns.forEach((b) => b.classList.remove("active"));
          document
            .querySelectorAll(".section")
            .forEach((s) => s.classList.remove("active"));
          btn.classList.add("active");
          document
            .getElementById("sec-" + btn.dataset.tab)
            .classList.add("active");
        });
      });

      // ==================== QUIZ ====================
      const quizQuestions = [
        {
          q: "A player receives the ball directly from a throw-in while standing past all defenders. Is this offside?",
          options: [
            "Yes, it's offside",
            "No, you can't be offside from a throw-in",
            "Only if they score",
            "Only in the penalty area",
          ],
          correct: 1,
          explanation:
            "You cannot be offside when receiving the ball directly from a throw-in. This also applies to goal kicks and corner kicks.",
        },
        {
          q: "At the moment a pass is made, the attacker is exactly level with the second-last defender. What's the call?",
          options: [
            "Offside ‚Äî they need to be behind the defender",
            "Onside ‚Äî level is NOT offside",
            "Depends on whether they score",
            "Only the referee can decide this",
          ],
          correct: 1,
          explanation:
            "Level is onside! If the attacker is level with the second-last defender, they are NOT in an offside position.",
        },
        {
          q: "A player is in an offside position but doesn't touch the ball and doesn't interfere with play. Is this an offence?",
          options: [
            "Yes, being in an offside position is always an offence",
            "No, they must be involved in active play for it to be penalised",
            "Yes, the referee should always stop play",
            "Only if they're in the penalty area",
          ],
          correct: 1,
          explanation:
            "Being in an offside position is NOT automatically an offence. The player must interfere with play, interfere with an opponent, or gain an advantage from the position.",
        },
        {
          q: "Which body parts are used to judge offside position?",
          options: [
            "Only the feet",
            "Any part of the body including arms",
            "Head, body, and feet ‚Äî NOT arms/hands",
            "Only the torso",
          ],
          correct: 2,
          explanation:
            "Offside position is judged using any body part with which a player can legitimately play the ball ‚Äî head, body, and feet. Arms and hands do NOT count.",
        },
        {
          q: "The goalkeeper has come up for a corner. Now there's only one defender back. An attacker is behind that defender but ahead of where the goalkeeper was. Is this offside?",
          options: [
            "No, the goalkeeper doesn't count",
            "Yes ‚Äî with only one defender between attacker and goal, they need to be behind that player",
            "It depends on whether the goalie is in their area",
            "Only if they touch the ball",
          ],
          correct: 1,
          explanation:
            "The rule says TWO opponents (usually GK + 1 defender). If the GK is up the pitch, the last defender becomes 'one', so the attacker needs to be behind the SECOND-last opponent ‚Äî which would require being behind the GK too. With only one opponent between attacker and goal, the attacker is offside.",
        },
        {
          q: "A player is in their own half when a team-mate passes the ball forward. They sprint into the opponents' half to collect it. Offside?",
          options: [
            "Yes, because they ended up in the opponents' half",
            "No ‚Äî they were in their own half when the ball was played",
            "Only if they were running when the pass was made",
            "It depends on the speed of the ball",
          ],
          correct: 1,
          explanation:
            "A player in their own half at the moment the ball is played CANNOT be offside, regardless of where they end up when they receive the ball.",
        },
        {
          q: "When should you raise your flag as assistant referee?",
          options: [
            "As soon as a player is in an offside position",
            "When a player in an offside position becomes involved in active play",
            "When the attacking team scores",
            "Whenever you're unsure",
          ],
          correct: 1,
          explanation:
            "You should only flag when a player in an offside position becomes actively involved (touches the ball, interferes with an opponent, or gains an advantage). Just being in an offside position isn't enough.",
        },
        {
          q: "A defender deliberately kicks the ball forward and an attacker who was in an offside position picks it up. What's the call?",
          options: [
            "Offside ‚Äî the attacker was in an offside position",
            "Onside ‚Äî the ball was played by a defender",
            "It depends on whether it was a pass or a clearance",
            "Always offside if in the opponents' half",
          ],
          correct: 1,
          explanation:
            "If a defender deliberately plays the ball (not a deflection or save), the offside evaluation resets. The attacker who was in an offside position from the previous phase of play is now judged on the new phase. Since the ball was deliberately played by a defender, it's not offside.",
        },
        {
          q: "Which hand should you hold the flag in as assistant referee?",
          options: [
            "Always the right hand",
            "Always the left hand",
            "The hand nearest the referee",
            "It doesn't matter",
          ],
          correct: 2,
          explanation:
            "Hold the flag in the hand nearest the referee so it's most visible to them. You'll typically switch hands at half-time when you change ends.",
        },
        {
          q: "You're not sure if it was offside or not. What should you do?",
          options: [
            "Flag it anyway ‚Äî better safe than sorry",
            "Keep your flag down ‚Äî benefit of the doubt to the attacker",
            "Ask the parents watching",
            "Stop play yourself",
          ],
          correct: 1,
          explanation:
            "If in doubt, keep your flag DOWN. The standard approach is 'benefit of the doubt to the attacker'. It's better to miss a marginal offside than to incorrectly flag a legitimate attack.",
        },
      ];

      let currentQuiz = 0;
      let qScore = { correct: 0, wrong: 0 };
      let quizAnswered = false;

      function showQuizQuestion(idx) {
        const q = quizQuestions[idx];
        document.getElementById("quizQuestion").textContent =
          `Q${idx + 1}: ${q.q}`;

        const optDiv = document.getElementById("quizOptions");
        optDiv.innerHTML = "";

        q.options.forEach((opt, i) => {
          const btn = document.createElement("button");
          btn.className = "quiz-option";
          btn.textContent = opt;
          btn.onclick = () => submitQuizAnswer(i);
          optDiv.appendChild(btn);
        });

        document.getElementById("quizExplanation").classList.remove("show");
        document.getElementById("btnQuizNext").style.display = "none";
        document.getElementById("btnQuizReset").style.display = "none";
        quizAnswered = false;
      }

      function submitQuizAnswer(idx) {
        if (quizAnswered) return;
        quizAnswered = true;

        const q = quizQuestions[currentQuiz];
        const buttons = document.querySelectorAll(".quiz-option");

        buttons.forEach((btn, i) => {
          btn.disabled = true;
          if (i === q.correct) btn.classList.add("correct-answer");
          if (i === idx && idx !== q.correct) btn.classList.add("wrong-answer");
        });

        if (idx === q.correct) {
          qScore.correct++;
        } else {
          qScore.wrong++;
        }

        const total = qScore.correct + qScore.wrong;
        document.getElementById("qCorrect").textContent = "‚úì " + qScore.correct;
        document.getElementById("qWrong").textContent = "‚úó " + qScore.wrong;
        document.getElementById("qTotal").textContent =
          total + " / " + quizQuestions.length;
        document.getElementById("qProgress").style.width =
          (total / quizQuestions.length) * 100 + "%";

        const expl = document.getElementById("quizExplanation");
        expl.textContent = q.explanation;
        expl.classList.add("show");

        if (currentQuiz < quizQuestions.length - 1) {
          document.getElementById("btnQuizNext").style.display = "";
        } else {
          document.getElementById("btnQuizReset").style.display = "";
          const pct = Math.round((qScore.correct / quizQuestions.length) * 100);
          let msg =
            pct >= 80
              ? "üéâ Brilliant! You know your stuff!"
              : pct >= 60
                ? "üëç Not bad! Review the ones you missed."
                : "üìö Have another read of the Learn section and try again.";
          expl.textContent += `\n\nFinal Score: ${qScore.correct}/${quizQuestions.length} (${pct}%) ‚Äî ${msg}`;
        }
      }

      function nextQuizQuestion() {
        currentQuiz++;
        showQuizQuestion(currentQuiz);
      }

      function resetQuiz() {
        currentQuiz = 0;
        qScore = { correct: 0, wrong: 0 };
        document.getElementById("qCorrect").textContent = "‚úì 0";
        document.getElementById("qWrong").textContent = "‚úó 0";
        document.getElementById("qTotal").textContent =
          "0 / " + quizQuestions.length;
        document.getElementById("qProgress").style.width = "0%";
        showQuizQuestion(0);
      }

      // ==================== INIT ====================
      showQuizQuestion(0);

      // ==================== 3D INTERACTIVE MODE ====================
      (function () {
        "use strict";

        // ---- State ----
        let scene, camera, renderer, clock;
        let pitch, ball3d;
        let playerMeshes = [];
        let animMixer = null;
        let current3DScenario = 0;
        let answered3D = false;
        let frozen = false;
        let score3D = { correct: 0, wrong: 0, streak: 0 };
        let animState = "idle"; // 'playing', 'frozen', 'result'
        let animTime = 0;
        let currentCamMode = "linesman";
        let initialized = false;
        let passerKickTime = 0;
        let ballStartPos = null;
        let ballEndPos = null;
        let animDuration = 2.2; // seconds to animate before freeze
        let totalDuration = 3.2; // total scrub range (extends a bit past freeze)
        let offsideLineObj = null;
        let scenarioData3D = null;
        let playbackSpeed = 1;
        let isPlaying = true;
        let sliderDragging = false;
        let offsideLineForced = false;

        // Smooth camera state
        let camPos = { x: 15, y: 3.5, z: -28.5 }; // current interpolated position
        let camTarget = { x: 10, y: 0, z: 0 }; // current interpolated lookAt
        let camGoalPos = { x: 15, y: 3.5, z: -28.5 }; // desired position
        let camGoalTarget = { x: 10, y: 0, z: 0 }; // desired lookAt
        const CAM_SMOOTH = 0.06; // lower = smoother (0-1)

        // Pitch dimensions (Three.js units) ‚Äî a kids' pitch ~60m x 40m, we'll use 60x40
        const PW = 70,
          PH = 45;
        const HALF = PW / 2;

        // ---- 3D Scenarios ----
        // Positions: x = along pitch length (-HALF to +HALF, attacking toward +x), z = across pitch (-PH/2 to +PH/2)
        const scenarios3D = [
          {
            title: "Through Ball ‚Äî Classic Offside",
            offside: true,
            passer: { x: 2, z: 5, team: "attack" },
            subject: { x: 22, z: -4 },
            attackers: [{ x: 8, z: 12 }],
            defenders: [
              { x: 18, z: -2 },
              { x: 16, z: 8 },
              { x: 14, z: 14 },
            ],
            gk: { x: 32, z: 0 },
            ballTarget: { x: 28, z: -6 },
            explanation:
              "The attacker is well beyond the second-last defender when the through ball is played. Classic offside ‚Äî flag goes up!",
          },
          {
            title: "Level With Defender ‚Äî Onside!",
            offside: false,
            passer: { x: -2, z: 8, team: "attack" },
            subject: { x: 16, z: -3 },
            attackers: [{ x: 5, z: -10 }],
            defenders: [
              { x: 16, z: 6 },
              { x: 12, z: 14 },
              { x: 10, z: -8 },
            ],
            gk: { x: 32, z: 0 },
            ballTarget: { x: 22, z: -5 },
            explanation:
              "The attacker is exactly LEVEL with the second-last defender. Level is onside! Remember: if any playable body part is level, they're onside.",
          },
          {
            title: "In Own Half ‚Äî Safe!",
            offside: false,
            passer: { x: -12, z: -3, team: "attack" },
            subject: { x: -3, z: 5 },
            attackers: [{ x: -15, z: 10 }],
            defenders: [
              { x: 8, z: 2 },
              { x: 10, z: 8 },
              { x: 12, z: -4 },
            ],
            gk: { x: 32, z: 0 },
            ballTarget: { x: 10, z: 6 },
            explanation:
              "The attacker is in their OWN half when the ball is played. You cannot be offside in your own half!",
          },
          {
            title: "Goalkeeper Up ‚Äî Watch Out!",
            offside: true,
            passer: { x: 5, z: 6, team: "attack" },
            subject: { x: 28, z: -2 },
            attackers: [{ x: 10, z: 14 }],
            defenders: [{ x: 24, z: 3 }],
            gk: { x: 12, z: -8 },
            ballTarget: { x: 30, z: -3 },
            explanation:
              "The goalkeeper has come way out! Now the second-last opponent is the GK at x=12. The attacker is miles past both ‚Äî offside!",
          },
          {
            title: "Well-Timed Run",
            offside: false,
            passer: { x: 0, z: -6, team: "attack" },
            subject: { x: 14, z: 4 },
            attackers: [{ x: 4, z: -14 }],
            defenders: [
              { x: 16, z: 0 },
              { x: 18, z: 7 },
              { x: 13, z: 14 },
            ],
            gk: { x: 32, z: 0 },
            ballTarget: { x: 24, z: 5 },
            explanation:
              "At the moment the pass is made, the attacker is BEHIND the second-last defender. They'll run past them as the ball travels ‚Äî perfectly timed! Onside.",
          },
          {
            title: "Throw-In ‚Äî No Offside!",
            offside: false,
            passer: { x: 14, z: -22, team: "attack", isThrowIn: true },
            subject: { x: 26, z: -8 },
            attackers: [{ x: 12, z: 8 }],
            defenders: [
              { x: 20, z: -4 },
              { x: 18, z: 6 },
            ],
            gk: { x: 32, z: 0 },
            ballTarget: { x: 26, z: -8 },
            explanation:
              "This is a THROW-IN! You cannot be offside directly from a throw-in, no matter where you are. Keep your flag down!",
          },
          {
            title: "Behind the Ball ‚Äî Onside",
            offside: false,
            passer: { x: 18, z: 0, team: "attack" },
            subject: { x: 14, z: -6 },
            attackers: [{ x: 8, z: 10 }],
            defenders: [
              { x: 12, z: 5 },
              { x: 10, z: -8 },
            ],
            gk: { x: 32, z: 0 },
            ballTarget: { x: 24, z: -8 },
            explanation:
              "The attacker is BEHIND the ball when it's played. A player behind the ball can never be offside, even past all defenders.",
          },
          {
            title: "Tight Call ‚Äî Just Offside",
            offside: true,
            passer: { x: 3, z: 3, team: "attack" },
            subject: { x: 19, z: -5 },
            attackers: [{ x: 6, z: 12 }],
            defenders: [
              { x: 17, z: 0 },
              { x: 15, z: 10 },
              { x: 18, z: -12 },
            ],
            gk: { x: 32, z: 0 },
            ballTarget: { x: 25, z: -6 },
            explanation:
              "This is tight! The second-last defender is at x=17 and our attacker is at x=19 ‚Äî just beyond. Even a small distance counts. In a real game, benefit of doubt goes to the attacker for marginal calls.",
          },
        ];

        // ---- Initialization ----
        function init3D() {
          if (initialized) return;
          initialized = true;

          const container = document.getElementById("scene3d-container");
          const W = container.clientWidth || 880;
          const H = Math.round(W * 0.56);

          // Scene
          scene = new THREE.Scene();
          scene.background = new THREE.Color(0x87ceeb); // sky
          scene.fog = new THREE.Fog(0x87ceeb, 80, 160);

          // Renderer
          renderer = new THREE.WebGLRenderer({ antialias: true });
          renderer.setSize(W, H);
          renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
          renderer.shadowMap.enabled = true;
          renderer.shadowMap.type = THREE.PCFSoftShadowMap;
          container.appendChild(renderer.domElement);

          // Camera
          camera = new THREE.PerspectiveCamera(50, W / H, 0.1, 200);
          setCameraPosition("linesman", true);

          // Lights
          const ambient = new THREE.AmbientLight(0xffffff, 0.5);
          scene.add(ambient);

          const sun = new THREE.DirectionalLight(0xffffff, 0.8);
          sun.position.set(20, 40, 10);
          sun.castShadow = true;
          sun.shadow.camera.left = -50;
          sun.shadow.camera.right = 50;
          sun.shadow.camera.top = 35;
          sun.shadow.camera.bottom = -35;
          sun.shadow.mapSize.width = 2048;
          sun.shadow.mapSize.height = 2048;
          scene.add(sun);

          const fill = new THREE.DirectionalLight(0xffffff, 0.3);
          fill.position.set(-15, 20, -10);
          scene.add(fill);

          // Build pitch
          buildPitch();

          // Clock
          clock = new THREE.Clock();

          // Resize
          window.addEventListener("resize", () => {
            const w = container.clientWidth;
            const h = Math.round(w * 0.56);
            renderer.setSize(w, h);
            camera.aspect = w / h;
            camera.updateProjectionMatrix();
          });

          // Set up slider events
          setupSliderEvents();

          // Start render loop
          animate();

          // Load first scenario
          load3DScenario(0);
        }

        // ---- Build 3D Pitch ----
        function buildPitch() {
          // Ground (large grass plane)
          const groundGeo = new THREE.PlaneGeometry(160, 120);
          const groundMat = new THREE.MeshLambertMaterial({ color: 0x3a8c3f });
          const ground = new THREE.Mesh(groundGeo, groundMat);
          ground.rotation.x = -Math.PI / 2;
          ground.position.y = -0.05;
          ground.receiveShadow = true;
          scene.add(ground);

          // Pitch surface with stripes
          const pitchGroup = new THREE.Group();
          const stripeW = PW / 10;
          for (let i = 0; i < 10; i++) {
            const geo = new THREE.PlaneGeometry(stripeW, PH);
            const col = i % 2 === 0 ? 0x3e9442 : 0x45a04a;
            const mat = new THREE.MeshLambertMaterial({ color: col });
            const stripe = new THREE.Mesh(geo, mat);
            stripe.rotation.x = -Math.PI / 2;
            stripe.position.set(-HALF + stripeW / 2 + i * stripeW, 0, 0);
            stripe.receiveShadow = true;
            pitchGroup.add(stripe);
          }
          scene.add(pitchGroup);

          // Lines
          const lineMat = new THREE.MeshBasicMaterial({ color: 0xffffff });

          function makeLine(x1, z1, x2, z2, width) {
            const dx = x2 - x1,
              dz = z2 - z1;
            const len = Math.sqrt(dx * dx + dz * dz);
            const geo = new THREE.PlaneGeometry(len, width || 0.15);
            const line = new THREE.Mesh(geo, lineMat);
            line.rotation.x = -Math.PI / 2;
            line.position.set((x1 + x2) / 2, 0.01, (z1 + z2) / 2);
            line.rotation.z = -Math.atan2(dz, dx);
            scene.add(line);
          }

          // Pitch outline
          makeLine(-HALF, -PH / 2, HALF, -PH / 2);
          makeLine(-HALF, PH / 2, HALF, PH / 2);
          makeLine(-HALF, -PH / 2, -HALF, PH / 2);
          makeLine(HALF, -PH / 2, HALF, PH / 2);

          // Halfway line
          makeLine(0, -PH / 2, 0, PH / 2, 0.15);

          // Centre circle
          const ccGeo = new THREE.RingGeometry(6, 6.15, 48);
          const cc = new THREE.Mesh(ccGeo, lineMat);
          cc.rotation.x = -Math.PI / 2;
          cc.position.y = 0.01;
          scene.add(cc);

          // Centre spot
          const csDot = new THREE.Mesh(
            new THREE.CircleGeometry(0.3, 16),
            lineMat,
          );
          csDot.rotation.x = -Math.PI / 2;
          csDot.position.y = 0.01;
          scene.add(csDot);

          // Penalty areas
          const paW = 14,
            paH = 28;
          // Right
          makeLine(HALF, -paH / 2, HALF - paW, -paH / 2);
          makeLine(HALF, paH / 2, HALF - paW, paH / 2);
          makeLine(HALF - paW, -paH / 2, HALF - paW, paH / 2);
          // Left
          makeLine(-HALF, -paH / 2, -HALF + paW, -paH / 2);
          makeLine(-HALF, paH / 2, -HALF + paW, paH / 2);
          makeLine(-HALF + paW, -paH / 2, -HALF + paW, paH / 2);

          // Goal area (6-yard box)
          const gaW = 5,
            gaH = 14;
          makeLine(HALF, -gaH / 2, HALF - gaW, -gaH / 2);
          makeLine(HALF, gaH / 2, HALF - gaW, gaH / 2);
          makeLine(HALF - gaW, -gaH / 2, HALF - gaW, gaH / 2);
          makeLine(-HALF, -gaH / 2, -HALF + gaW, -gaH / 2);
          makeLine(-HALF, gaH / 2, -HALF + gaW, gaH / 2);
          makeLine(-HALF + gaW, -gaH / 2, -HALF + gaW, gaH / 2);

          // Goals (3D posts)
          buildGoal(HALF, 0);
          buildGoal(-HALF, 0, true);
        }

        function buildGoal(x, z, flip) {
          const postMat = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            metalness: 0.6,
            roughness: 0.3,
          });
          const postRadius = 0.12,
            goalW = 5.5,
            goalH = 2.2,
            goalD = 1.5;
          const dir = flip ? 1 : -1;

          // Posts
          const postGeo = new THREE.CylinderGeometry(
            postRadius,
            postRadius,
            goalH,
            8,
          );
          const lPost = new THREE.Mesh(postGeo, postMat);
          lPost.position.set(x, goalH / 2, -goalW / 2);
          lPost.castShadow = true;
          scene.add(lPost);

          const rPost = new THREE.Mesh(postGeo, postMat);
          rPost.position.set(x, goalH / 2, goalW / 2);
          rPost.castShadow = true;
          scene.add(rPost);

          // Crossbar
          const barGeo = new THREE.CylinderGeometry(
            postRadius,
            postRadius,
            goalW,
            8,
          );
          const bar = new THREE.Mesh(barGeo, postMat);
          bar.rotation.x = Math.PI / 2;
          bar.position.set(x, goalH, 0);
          bar.castShadow = true;
          scene.add(bar);

          // Net (semi-transparent)
          const netMat = new THREE.MeshBasicMaterial({
            color: 0xcccccc,
            transparent: true,
            opacity: 0.25,
            side: THREE.DoubleSide,
          });
          // Back
          const backNet = new THREE.Mesh(
            new THREE.PlaneGeometry(goalW, goalH),
            netMat,
          );
          backNet.position.set(x + dir * goalD, goalH / 2, 0);
          scene.add(backNet);
          // Top
          const topNet = new THREE.Mesh(
            new THREE.PlaneGeometry(goalD, goalW),
            netMat,
          );
          topNet.rotation.x = Math.PI / 2;
          topNet.rotation.z = Math.PI / 2;
          topNet.position.set(x + (dir * goalD) / 2, goalH, 0);
          scene.add(topNet);
          // Sides
          const sideNet = new THREE.Mesh(
            new THREE.PlaneGeometry(goalD, goalH),
            netMat,
          );
          sideNet.rotation.y = Math.PI / 2;
          sideNet.position.set(x + (dir * goalD) / 2, goalH / 2, -goalW / 2);
          scene.add(sideNet);
          const sideNet2 = sideNet.clone();
          sideNet2.position.z = goalW / 2;
          scene.add(sideNet2);
        }

        // ---- Create a 3D Player Figure ----
        function createPlayer(color, isGK, isSubject) {
          const group = new THREE.Group();

          // Body (cylinder)
          const bodyGeo = new THREE.CylinderGeometry(0.35, 0.4, 1.1, 12);
          const bodyMat = new THREE.MeshStandardMaterial({
            color: color,
            roughness: 0.5,
          });
          const body = new THREE.Mesh(bodyGeo, bodyMat);
          body.position.y = 1.15;
          body.castShadow = true;
          group.add(body);

          // Shorts
          const shortsGeo = new THREE.CylinderGeometry(0.4, 0.35, 0.4, 12);
          const shortsMat = new THREE.MeshStandardMaterial({
            color: isGK ? 0x333333 : color === 0x1565c0 ? 0x0d2f6e : 0x7a1a1a,
            roughness: 0.6,
          });
          const shorts = new THREE.Mesh(shortsGeo, shortsMat);
          shorts.position.y = 0.6;
          shorts.castShadow = true;
          group.add(shorts);

          // Head
          const headGeo = new THREE.SphereGeometry(0.28, 12, 10);
          const headMat = new THREE.MeshStandardMaterial({
            color: 0xf0c8a0,
            roughness: 0.7,
          });
          const head = new THREE.Mesh(headGeo, headMat);
          head.position.y = 1.98;
          head.castShadow = true;
          group.add(head);

          // Legs
          const legGeo = new THREE.CylinderGeometry(0.1, 0.12, 0.7, 8);
          const legMat = new THREE.MeshStandardMaterial({
            color: 0xf0c8a0,
            roughness: 0.7,
          });
          const legL = new THREE.Mesh(legGeo, legMat);
          legL.position.set(-0.15, 0.2, 0);
          group.add(legL);
          const legR = new THREE.Mesh(legGeo, legMat);
          legR.position.set(0.15, 0.2, 0);
          group.add(legR);
          group.userData.legL = legL;
          group.userData.legR = legR;

          // Boots
          const bootGeo = new THREE.BoxGeometry(0.18, 0.12, 0.3);
          const bootMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
          const bootL = new THREE.Mesh(bootGeo, bootMat);
          bootL.position.set(-0.15, -0.08, 0.05);
          group.add(bootL);
          const bootR = new THREE.Mesh(bootGeo, bootMat);
          bootR.position.set(0.15, -0.08, 0.05);
          group.add(bootR);
          group.userData.bootL = bootL;
          group.userData.bootR = bootR;

          // Arms
          const armGeo = new THREE.CylinderGeometry(0.07, 0.08, 0.6, 8);
          const armMat = new THREE.MeshStandardMaterial({
            color: color,
            roughness: 0.5,
          });
          const armL = new THREE.Mesh(armGeo, armMat);
          armL.position.set(-0.48, 1.2, 0);
          armL.rotation.z = 0.2;
          group.add(armL);
          const armR = new THREE.Mesh(armGeo, armMat);
          armR.position.set(0.48, 1.2, 0);
          armR.rotation.z = -0.2;
          group.add(armR);
          group.userData.armL = armL;
          group.userData.armR = armR;

          // Subject highlight ring
          if (isSubject) {
            const ringGeo = new THREE.RingGeometry(0.6, 0.75, 32);
            const ringMat = new THREE.MeshBasicMaterial({
              color: 0xfdd835,
              side: THREE.DoubleSide,
            });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.rotation.x = -Math.PI / 2;
            ring.position.y = 0.02;
            group.add(ring);

            // Floating arrow above
            const arrowGeo = new THREE.ConeGeometry(0.25, 0.5, 8);
            const arrowMat = new THREE.MeshBasicMaterial({ color: 0xfdd835 });
            const arrow = new THREE.Mesh(arrowGeo, arrowMat);
            arrow.position.y = 2.8;
            arrow.rotation.x = Math.PI;
            group.add(arrow);
            group.userData.arrow = arrow;
          }

          // GK gloves
          if (isGK) {
            const gloveMat = new THREE.MeshStandardMaterial({
              color: 0x76ff03,
            });
            const gloveGeo = new THREE.SphereGeometry(0.1, 8, 6);
            const gloveL = new THREE.Mesh(gloveGeo, gloveMat);
            gloveL.position.set(-0.5, 0.95, 0);
            group.add(gloveL);
            const gloveR = new THREE.Mesh(gloveGeo, gloveMat);
            gloveR.position.set(0.5, 0.95, 0);
            group.add(gloveR);
          }

          // Shadow disc
          const shadowGeo = new THREE.CircleGeometry(0.42, 16);
          const shadowMat = new THREE.MeshBasicMaterial({
            color: 0x000000,
            transparent: true,
            opacity: 0.2,
          });
          const shadow = new THREE.Mesh(shadowGeo, shadowMat);
          shadow.rotation.x = -Math.PI / 2;
          shadow.position.y = 0.01;
          group.add(shadow);

          return group;
        }

        // ---- Create Ball ----
        function createBall() {
          const group = new THREE.Group();
          const ballGeo = new THREE.SphereGeometry(0.22, 16, 12);
          const ballMat = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            roughness: 0.4,
            metalness: 0.1,
          });
          const sphere = new THREE.Mesh(ballGeo, ballMat);
          sphere.castShadow = true;
          group.add(sphere);

          // Pentagon pattern (simplified ‚Äî dark patches)
          const patchGeo = new THREE.SphereGeometry(0.225, 5, 1);
          const patchMat = new THREE.MeshStandardMaterial({
            color: 0x222222,
            roughness: 0.5,
          });
          const patch = new THREE.Mesh(patchGeo, patchMat);
          patch.scale.set(0.4, 0.4, 0.4);
          patch.position.set(0.15, 0.08, 0.1);
          group.add(patch);
          const patch2 = patch.clone();
          patch2.position.set(-0.1, 0.12, -0.12);
          group.add(patch2);
          const patch3 = patch.clone();
          patch3.position.set(0.05, -0.15, 0.08);
          group.add(patch3);

          // Ball shadow
          const shadowGeo = new THREE.CircleGeometry(0.25, 12);
          const shadowMat = new THREE.MeshBasicMaterial({
            color: 0x000000,
            transparent: true,
            opacity: 0.18,
          });
          const shadow = new THREE.Mesh(shadowGeo, shadowMat);
          shadow.rotation.x = -Math.PI / 2;
          shadow.position.y = -0.2;
          group.add(shadow);
          group.userData.shadow = shadow;

          return group;
        }

        // ---- Offside Line ----
        function createOffsideLine(xPos) {
          if (offsideLineObj) scene.remove(offsideLineObj);
          const group = new THREE.Group();

          // Dashed line across pitch
          const lineGeo = new THREE.PlaneGeometry(0.12, PH + 2);
          const lineMat = new THREE.MeshBasicMaterial({
            color: 0xff3333,
            transparent: true,
            opacity: 0.7,
            side: THREE.DoubleSide,
          });
          const line = new THREE.Mesh(lineGeo, lineMat);
          line.rotation.x = -Math.PI / 2;
          line.rotation.z = Math.PI / 2;
          line.position.set(xPos, 0.03, 0);
          group.add(line);

          // Vertical transparent wall for visibility
          const wallGeo = new THREE.PlaneGeometry(0.08, 3);
          const wallMat = new THREE.MeshBasicMaterial({
            color: 0xff3333,
            transparent: true,
            opacity: 0.12,
            side: THREE.DoubleSide,
          });
          for (let z = -PH / 2; z <= PH / 2; z += 3) {
            const wall = new THREE.Mesh(wallGeo, wallMat);
            wall.position.set(xPos, 1.5, z);
            group.add(wall);
          }

          scene.add(group);
          offsideLineObj = group;
          offsideLineObj.visible = false; // hidden until freeze
        }

        // ---- Camera Positions ----
        function getBaseCameraForMode(mode) {
          switch (mode) {
            case "linesman":
              return {
                pos: { x: 15, y: 3.5, z: -PH / 2 - 6 },
                target: { x: 10, y: 0, z: 0 },
              };
            case "broadcast":
              return {
                pos: { x: -5, y: 28, z: -35 },
                target: { x: 5, y: 0, z: 2 },
              };
            case "topdown":
              return {
                pos: { x: 5, y: 50, z: 0 },
                target: { x: 5, y: 0, z: 0 },
              };
            case "behindgoal":
              return {
                pos: { x: HALF + 10, y: 6, z: 0 },
                target: { x: 0, y: 0, z: 0 },
              };
            default:
              return {
                pos: { x: 15, y: 3.5, z: -PH / 2 - 6 },
                target: { x: 10, y: 0, z: 0 },
              };
          }
        }

        function setCameraPosition(mode, instant) {
          currentCamMode = mode;
          // Update buttons
          document
            .querySelectorAll(".cam-btn")
            .forEach((b) => b.classList.remove("active"));
          const btn = document.getElementById(
            "cam" + mode.charAt(0).toUpperCase() + mode.slice(1),
          );
          if (btn) btn.classList.add("active");

          if (!camera) return;

          const base = getBaseCameraForMode(mode);
          camGoalPos = { ...base.pos };
          camGoalTarget = { ...base.target };

          if (instant) {
            // Snap immediately (used on first load)
            camPos = { ...camGoalPos };
            camTarget = { ...camGoalTarget };
            camera.position.set(camPos.x, camPos.y, camPos.z);
            camera.lookAt(camTarget.x, camTarget.y, camTarget.z);
          }
        }

        function smoothLerp(current, goal, factor) {
          return current + (goal - current) * factor;
        }

        function updateCamera(t) {
          if (!camera || !scenarioData3D) return;

          const s = scenarioData3D;
          const smoothFactor = CAM_SMOOTH;

          // Compute desired camera goal based on mode and animation time
          const base = getBaseCameraForMode(currentCamMode);

          if (currentCamMode === "linesman") {
            // Phase 1: Gently track center of action
            if (t < passerKickTime) {
              const preT = t / passerKickTime;
              // Slowly pan to keep the developing play in view
              const midX = (s.passer.x + s.subject.x) / 2;
              camGoalPos.x = lerp(base.pos.x, midX, preT * 0.3);
              camGoalPos.y = base.pos.y;
              camGoalPos.z = base.pos.z;
              camGoalTarget.x = lerp(base.target.x, midX, preT * 0.4);
              camGoalTarget.y = 0.5;
              camGoalTarget.z = lerp(
                base.target.z,
                (s.passer.z + s.subject.z) / 2,
                preT * 0.3,
              );
            }
            // Phase 2: Smoothly transition to follow the subject
            else {
              const kickT =
                (t - passerKickTime) / (animDuration - passerKickTime);
              const easedT = Math.min(kickT, 1);
              // Ease in-out for smooth tracking
              const smoothT = easedT * easedT * (3 - 2 * easedT);
              const subjectX = s.subject.x + easedT * 2; // matches subject run
              camGoalPos.x = lerp(
                (s.passer.x + s.subject.x) / 2,
                subjectX - 3,
                smoothT,
              );
              camGoalPos.y = lerp(base.pos.y, 3, smoothT * 0.3);
              camGoalPos.z = base.pos.z;
              camGoalTarget.x = lerp(
                (s.passer.x + s.subject.x) / 2,
                subjectX,
                smoothT,
              );
              camGoalTarget.y = lerp(0.5, 1, smoothT);
              camGoalTarget.z = lerp(
                (s.passer.z + s.subject.z) / 2,
                s.subject.z,
                smoothT,
              );
            }
          } else if (currentCamMode === "broadcast") {
            // Subtle pan to follow the action
            if (t >= passerKickTime) {
              const kickT =
                (t - passerKickTime) / (animDuration - passerKickTime);
              const easedT = Math.min(kickT, 1);
              const smoothT = easedT * easedT * (3 - 2 * easedT);
              const midX = lerp(
                s.passer.x,
                (s.passer.x + s.subject.x) / 2,
                smoothT,
              );
              camGoalTarget.x = lerp(base.target.x, midX, 0.4);
            } else {
              camGoalPos = { ...base.pos };
              camGoalTarget = { ...base.target };
            }
          } else {
            // topdown / behindgoal ‚Äî minimal tracking
            camGoalPos = { ...base.pos };
            camGoalTarget = { ...base.target };
          }

          // Smoothly interpolate toward goals
          camPos.x = smoothLerp(camPos.x, camGoalPos.x, smoothFactor);
          camPos.y = smoothLerp(camPos.y, camGoalPos.y, smoothFactor);
          camPos.z = smoothLerp(camPos.z, camGoalPos.z, smoothFactor);
          camTarget.x = smoothLerp(camTarget.x, camGoalTarget.x, smoothFactor);
          camTarget.y = smoothLerp(camTarget.y, camGoalTarget.y, smoothFactor);
          camTarget.z = smoothLerp(camTarget.z, camGoalTarget.z, smoothFactor);

          camera.position.set(camPos.x, camPos.y, camPos.z);
          camera.lookAt(camTarget.x, camTarget.y, camTarget.z);
        }

        window.setCamera = function (mode) {
          setCameraPosition(mode, false);
        };

        // ---- Load scenario ----
        function load3DScenario(idx) {
          scenarioData3D = scenarios3D[idx];
          answered3D = false;
          frozen = false;
          animState = "playing";
          animTime = 0;

          // Clear existing players
          playerMeshes.forEach((m) => scene.remove(m));
          playerMeshes = [];
          if (ball3d) scene.remove(ball3d);

          const s = scenarioData3D;

          // Create passer
          const passer = createPlayer(0x1565c0, false, false);
          passer.position.set(s.passer.x, 0, s.passer.z);
          passer.lookAt(s.ballTarget.x, 0, s.ballTarget.z);
          scene.add(passer);
          playerMeshes.push(passer);
          passer.userData.role = "passer";
          passer.userData.startX = s.passer.x;
          passer.userData.startZ = s.passer.z;

          // Create subject
          const subject = createPlayer(0x1565c0, false, true);
          subject.position.set(s.subject.x, 0, s.subject.z);
          subject.lookAt(HALF, 0, s.subject.z);
          scene.add(subject);
          playerMeshes.push(subject);
          subject.userData.role = "subject";
          subject.userData.startX = s.subject.x;
          subject.userData.startZ = s.subject.z;

          // Other attackers
          s.attackers.forEach((a) => {
            const atk = createPlayer(0x1565c0, false, false);
            atk.position.set(a.x, 0, a.z);
            atk.lookAt(HALF, 0, a.z);
            scene.add(atk);
            playerMeshes.push(atk);
            atk.userData.role = "attacker";
            atk.userData.startX = a.x;
            atk.userData.startZ = a.z;
          });

          // Defenders
          s.defenders.forEach((d) => {
            const def = createPlayer(0xc62828, false, false);
            def.position.set(d.x, 0, d.z);
            def.lookAt(-HALF, 0, d.z);
            scene.add(def);
            playerMeshes.push(def);
            def.userData.role = "defender";
            def.userData.startX = d.x;
            def.userData.startZ = d.z;
          });

          // Goalkeeper
          const gk = createPlayer(0xff9800, true, false);
          gk.position.set(s.gk.x, 0, s.gk.z);
          gk.lookAt(0, 0, 0);
          scene.add(gk);
          playerMeshes.push(gk);
          gk.userData.role = "gk";
          gk.userData.startX = s.gk.x;
          gk.userData.startZ = s.gk.z;

          // Ball
          ball3d = createBall();
          ball3d.position.set(s.passer.x + 0.6, 0.22, s.passer.z);
          scene.add(ball3d);
          ballStartPos = { x: s.passer.x + 0.6, z: s.passer.z };
          ballEndPos = { x: s.ballTarget.x, z: s.ballTarget.z };

          // Offside line
          let defXs = s.defenders.map((d) => d.x);
          defXs.push(s.gk.x);
          defXs.sort((a, b) => b - a);
          const offsideX = defXs[1]; // second-last opponent
          createOffsideLine(offsideX);

          // Update HUD
          document.getElementById("hud-scenario").textContent =
            idx + 1 + " / " + scenarios3D.length;
          document.getElementById("hud-streak").textContent =
            "üî• " + score3D.streak;

          // Reset UI
          document.getElementById("freezeBanner").style.display = "none";
          document.getElementById("decisionButtons").style.display = "none";
          document.getElementById("result3d").className = "result-3d";
          document.getElementById("btn3dOffside").disabled = false;
          document.getElementById("btn3dOnside").disabled = false;
          document.getElementById("btn3dNext").style.display = "none";
          document.getElementById("btn3dRestart").style.display = "none";
          document.getElementById("explanation3d").classList.remove("show");
          offsideLineForced = false;

          // Camera follows linesman-style
          setCameraPosition(currentCamMode, true);

          // Set duration that allows some pre-kick movement
          passerKickTime = 1.2; // passer kicks at 1.2s
          animDuration = 2.2; // freeze at 2.2s (1s after kick)
          totalDuration = 3.2; // slider goes slightly past freeze

          // Reset playback state
          isPlaying = true;
          document.getElementById("btnPlayPause").textContent = "‚è∏";

          // Set up timeline slider
          const slider = document.getElementById("timelineSlider");
          slider.value = 0;
          updateSliderFill(0);
          document.getElementById("timelineCurrent").textContent = "0.0s";
          document.getElementById("timelineTotal").textContent =
            totalDuration.toFixed(1) + "s";
          document.getElementById("timelinePhase").textContent = "‚ñ∂ Build-up";

          // Position the kick marker on the slider
          const kickPct = (passerKickTime / totalDuration) * 100;
          document.getElementById("kickMarker").style.left = kickPct + "%";
        }

        // ---- Timeline Slider ----
        function setupSliderEvents() {
          const slider = document.getElementById("timelineSlider");
          if (!slider) return;

          slider.addEventListener("input", () => {
            sliderDragging = true;
            const pct = slider.value / 1000;
            animTime = pct * totalDuration;
            applySceneAtTime(animTime);
            updateTimelineUI(animTime);
          });

          slider.addEventListener("pointerdown", () => {
            sliderDragging = true;
            isPlaying = false;
            document.getElementById("btnPlayPause").textContent = "‚ñ∂";
          });

          slider.addEventListener("pointerup", () => {
            sliderDragging = false;
          });

          slider.addEventListener("change", () => {
            sliderDragging = false;
          });
        }

        function updateSliderFill(pct) {
          const slider = document.getElementById("timelineSlider");
          if (slider) slider.style.setProperty("--fill", pct * 100 + "%");
        }

        function updateTimelineUI(t) {
          const pct = Math.min(t / totalDuration, 1);
          const slider = document.getElementById("timelineSlider");
          if (slider && !sliderDragging) slider.value = Math.round(pct * 1000);
          updateSliderFill(pct);

          document.getElementById("timelineCurrent").textContent =
            t.toFixed(1) + "s";

          // Phase indicator
          const phase = document.getElementById("timelinePhase");
          if (t < passerKickTime) {
            phase.textContent = "‚ñ∂ Build-up";
            phase.style.color = "#aaa";
          } else if (t < animDuration) {
            phase.textContent = "‚ö° Ball in flight ‚Äî WATCH THE POSITIONS!";
            phase.style.color = "#fdd835";
          } else {
            phase.textContent = "‚è∏ Moment of the pass ‚Äî Make your call!";
            phase.style.color = "#69f0ae";
          }
        }

        // Apply the scene state at any given time (for scrubbing)
        function applySceneAtTime(t) {
          if (!scenarioData3D) return;
          animateScenario(t, 0);
          updateCamera(t);

          // Show/hide offside line based on time
          if (offsideLineObj) {
            offsideLineObj.visible = offsideLineForced || t >= animDuration;
          }

          // Show/hide freeze banner & buttons
          if (t >= animDuration && !answered3D) {
            document.getElementById("freezeBanner").style.display = "block";
            document.getElementById("decisionButtons").style.display = "flex";
            frozen = true;
          } else if (t < animDuration) {
            if (!answered3D) {
              document.getElementById("freezeBanner").style.display = "none";
              document.getElementById("decisionButtons").style.display = "none";
            }
            frozen = false;
          }
        }

        // Playback controls
        window.togglePlayPause = function () {
          isPlaying = !isPlaying;
          document.getElementById("btnPlayPause").textContent = isPlaying
            ? "‚è∏"
            : "‚ñ∂";
          if (isPlaying && animTime >= totalDuration) {
            animTime = 0; // restart if at end
          }
        };

        window.stepFrame = function (delta) {
          isPlaying = false;
          document.getElementById("btnPlayPause").textContent = "‚ñ∂";
          animTime = Math.max(0, Math.min(totalDuration, animTime + delta));
          applySceneAtTime(animTime);
          updateTimelineUI(animTime);
        };

        window.cycleSpeed = function () {
          const speeds = [0.25, 0.5, 1, 1.5, 2];
          const idx = speeds.indexOf(playbackSpeed);
          playbackSpeed = speeds[(idx + 1) % speeds.length];
          document.getElementById("btnSpeed").textContent = playbackSpeed + "√ó";
        };

        window.toggleOffsideLine = function () {
          offsideLineForced = !offsideLineForced;
          const btn = document.getElementById("btnShowLine");
          btn.classList.toggle("active", offsideLineForced);
          if (offsideLineObj) {
            offsideLineObj.visible =
              offsideLineForced || animTime >= animDuration;
          }
        };

        // ---- Animation Loop ----
        function animate() {
          requestAnimationFrame(animate);
          if (!renderer) return;

          const dt = clock.getDelta();

          if (
            scenarioData3D &&
            isPlaying &&
            !sliderDragging &&
            animState !== "result"
          ) {
            animTime += dt * playbackSpeed;

            // Clamp within total scrub range
            if (animTime > totalDuration) {
              animTime = totalDuration;
              isPlaying = false;
              document.getElementById("btnPlayPause").textContent = "‚ñ∂";
            }

            applySceneAtTime(animTime);
            updateTimelineUI(animTime);

            if (animTime >= animDuration && !frozen && !answered3D) {
              freezeScene();
            }
          }

          // Idle animations (breathing, arrow bob)
          playerMeshes.forEach((p, i) => {
            const body = p.children[0];
            if (body)
              body.scale.y = 1 + Math.sin(clock.elapsedTime * 2 + i) * 0.01;

            if (p.userData.arrow) {
              p.userData.arrow.position.y =
                2.8 + Math.sin(clock.elapsedTime * 3) * 0.15;
            }
          });

          // Ball spin when in flight
          if (
            ball3d &&
            animTime > passerKickTime &&
            (isPlaying || sliderDragging)
          ) {
            ball3d.children[0].rotation.x += dt * 8;
            ball3d.children[0].rotation.z += dt * 3;
          }

          // Always keep camera smoothly interpolating (for camera mode switches during pause/result)
          if (scenarioData3D && !isPlaying && !sliderDragging) {
            updateCamera(animTime);
          }

          renderer.render(scene, camera);
        }

        // ---- Animate the scenario ----
        function animateScenario(t, dt) {
          const s = scenarioData3D;

          // Phase 1: Pre-kick (0 to passerKickTime) ‚Äî players jog/move slightly
          if (t < passerKickTime) {
            const preT = t / passerKickTime; // 0..1

            // Passer runs toward ball slightly
            const passer = playerMeshes.find(
              (p) => p.userData.role === "passer",
            );
            if (passer) {
              // Run animation (legs)
              animateRunning(passer, t, 5);
            }

            // Subject makes a forward run
            const subject = playerMeshes.find(
              (p) => p.userData.role === "subject",
            );
            if (subject) {
              const runDist = 3; // run forward 3 units during buildup
              subject.position.x = s.subject.x - runDist * (1 - preT);
              subject.position.z = s.subject.z;
              animateRunning(subject, t, 6);
            }

            // Other attackers shift
            let atkIdx = 0;
            playerMeshes
              .filter((p) => p.userData.role === "attacker")
              .forEach((atk) => {
                atk.position.x = s.attackers[atkIdx].x - 1 * (1 - preT);
                animateRunning(atk, t, 4);
                atkIdx++;
              });

            // Defenders shift
            let defIdx = 0;
            playerMeshes
              .filter((p) => p.userData.role === "defender")
              .forEach((def) => {
                const jitter = Math.sin(t * 3 + defIdx) * 0.3;
                def.position.z = s.defenders[defIdx].z + jitter;
                animateRunning(def, t, 3);
                defIdx++;
              });
          }

          // Phase 2: Kick and ball travel (passerKickTime to animDuration)
          if (t >= passerKickTime) {
            const kickT =
              (t - passerKickTime) / (animDuration - passerKickTime);
            const easedT = Math.min(kickT, 1);

            // Passer kick animation
            const passer = playerMeshes.find(
              (p) => p.userData.role === "passer",
            );
            if (passer) {
              const kickPhase = Math.min((t - passerKickTime) * 4, 1);
              if (passer.userData.legR) {
                passer.userData.legR.rotation.x =
                  -Math.sin(kickPhase * Math.PI) * 0.9;
              }
              if (passer.userData.bootR) {
                passer.userData.bootR.rotation.x =
                  -Math.sin(kickPhase * Math.PI) * 0.5;
              }
              if (passer.userData.armL) {
                passer.userData.armL.rotation.x =
                  Math.sin(kickPhase * Math.PI) * 0.4;
              }
              // Body lean
              passer.children[0].rotation.x =
                Math.sin(kickPhase * Math.PI) * 0.1;
            }

            // Ball trajectory (with arc for height)
            const bx =
              ballStartPos.x + (ballEndPos.x - ballStartPos.x) * easedT;
            const bz =
              ballStartPos.z + (ballEndPos.z - ballStartPos.z) * easedT;
            const arc = Math.sin(easedT * Math.PI) * 2.5; // height arc
            ball3d.position.set(bx, 0.22 + arc, bz);

            // Update ball shadow
            if (ball3d.userData.shadow) {
              ball3d.userData.shadow.position.y = -(0.22 + arc) + 0.02;
              ball3d.userData.shadow.scale.setScalar(1 + arc * 0.2);
              ball3d.userData.shadow.material.opacity = 0.18 / (1 + arc * 0.3);
            }

            // Subject continues run
            const subject = playerMeshes.find(
              (p) => p.userData.role === "subject",
            );
            if (subject) {
              const runExtra = easedT * 2;
              subject.position.x = s.subject.x + runExtra;
              animateRunning(subject, t, 8);
            }
          }
        }

        function animateRunning(player, t, speed) {
          if (player.userData.legL) {
            player.userData.legL.rotation.x = Math.sin(t * speed) * 0.5;
          }
          if (player.userData.legR) {
            player.userData.legR.rotation.x = -Math.sin(t * speed) * 0.5;
          }
          if (player.userData.armL) {
            player.userData.armL.rotation.x = -Math.sin(t * speed) * 0.3;
          }
          if (player.userData.armR) {
            player.userData.armR.rotation.x = Math.sin(t * speed) * 0.3;
          }
          // Slight body bob
          player.position.y = Math.abs(Math.sin(t * speed)) * 0.06;
        }

        function lerp(a, b, t) {
          return a + (b - a) * t;
        }

        // ---- Freeze ----
        function freezeScene() {
          frozen = true;
          animState = "frozen";
          isPlaying = false;
          document.getElementById("btnPlayPause").textContent = "‚ñ∂";

          // Show offside line
          if (offsideLineObj) offsideLineObj.visible = true;

          // Show freeze banner + buttons
          document.getElementById("freezeBanner").style.display = "block";
          document.getElementById("decisionButtons").style.display = "flex";

          // Play a freeze sound effect (optional visual flash)
          flashScreen();
        }

        function flashScreen() {
          const container = document.getElementById("scene3d-container");
          container.style.outline = "3px solid #fdd835";
          setTimeout(() => {
            container.style.outline = "none";
          }, 300);
        }

        // ---- Submit 3D Answer ----
        window.submit3DAnswer = function (isOffside) {
          if (answered3D) return;
          answered3D = true;

          const s = scenarios3D[current3DScenario];
          const correct = isOffside === s.offside;

          document.getElementById("btn3dOffside").disabled = true;
          document.getElementById("btn3dOnside").disabled = true;
          document.getElementById("freezeBanner").style.display = "none";

          const result = document.getElementById("result3d");
          const verdict = document.getElementById("result3dVerdict");
          const sub = document.getElementById("result3dSub");

          if (correct) {
            score3D.correct++;
            score3D.streak++;
            verdict.textContent = "‚úÖ CORRECT!";
            sub.textContent = s.offside
              ? "That IS offside ‚Äî good eye!"
              : "That is NOT offside ‚Äî well spotted!";
            result.className = "result-3d correct show";
          } else {
            score3D.wrong++;
            score3D.streak = 0;
            verdict.textContent = "‚ùå WRONG!";
            sub.textContent = s.offside
              ? "That IS offside ‚Äî the attacker was past the line."
              : "That is NOT offside ‚Äî keep your flag down!";
            result.className = "result-3d wrong show";
          }

          // Show explanation
          const expl = document.getElementById("explanation3d");
          expl.textContent = s.explanation;
          expl.classList.add("show");

          // Update scores
          const total = score3D.correct + score3D.wrong;
          document.getElementById("t3Correct").textContent =
            "‚úì " + score3D.correct;
          document.getElementById("t3Wrong").textContent = "‚úó " + score3D.wrong;
          document.getElementById("t3Total").textContent =
            total + " / " + scenarios3D.length;
          document.getElementById("t3Progress").style.width =
            (total / scenarios3D.length) * 100 + "%";
          document.getElementById("hud-streak").textContent =
            "üî• " + score3D.streak;

          // Show appropriate buttons
          if (current3DScenario < scenarios3D.length - 1) {
            document.getElementById("btn3dNext").style.display = "";
          } else {
            document.getElementById("btn3dRestart").style.display = "";
            const pct = Math.round(
              (score3D.correct / scenarios3D.length) * 100,
            );
            let msg =
              pct >= 80
                ? "üéâ Superb! You're ready for matchday!"
                : pct >= 60
                  ? "üëç Decent ‚Äî a few more rounds will sharpen you up."
                  : "üìö Keep at it! Try again and focus on the key moments.";
            expl.textContent += `\n\nFinal Score: ${score3D.correct}/${scenarios3D.length} (${pct}%) ‚Äî ${msg}`;
          }

          animState = "result";
        };

        // ---- Next / Replay / Restart ----
        window.next3DScenario = function () {
          current3DScenario++;
          load3DScenario(current3DScenario);
          clock.start();
        };

        window.replay3DScenario = function () {
          // If already answered, reset the answered state too for re-watching
          if (answered3D) {
            // Don't re-score, just let them re-watch the animation
            document.getElementById("result3d").className = "result-3d";
            document.getElementById("freezeBanner").style.display = "none";
            document.getElementById("decisionButtons").style.display = "none";
          }
          animTime = 0;
          frozen = false;
          animState = "playing";
          isPlaying = true;
          offsideLineForced = false;
          document.getElementById("btnPlayPause").textContent = "‚è∏";
          document.getElementById("btnShowLine").classList.remove("active");
          if (offsideLineObj) offsideLineObj.visible = false;

          // Reset ball and player positions to frame 0
          if (ball3d && ballStartPos) {
            ball3d.position.set(ballStartPos.x, 0.22, ballStartPos.z);
          }
          applySceneAtTime(0);
          updateTimelineUI(0);
          setCameraPosition(currentCamMode, true);
          clock.start();
        };

        window.restart3D = function () {
          current3DScenario = 0;
          score3D = { correct: 0, wrong: 0, streak: 0 };
          document.getElementById("t3Correct").textContent = "‚úì 0";
          document.getElementById("t3Wrong").textContent = "‚úó 0";
          document.getElementById("t3Total").textContent =
            "0 / " + scenarios3D.length;
          document.getElementById("t3Progress").style.width = "0%";
          load3DScenario(0);
          clock.start();
        };

        // ---- Tab activation hook ----
        const origNavHandler = () => {
          // Initialize 3D when tab becomes active
          const sec3d = document.getElementById("sec-3d");
          if (sec3d && sec3d.classList.contains("active")) {
            init3D();
          }
        };

        // Override tab navigation to hook init
        document.querySelectorAll("nav button").forEach((btn) => {
          btn.addEventListener("click", () => {
            setTimeout(origNavHandler, 50);
          });
        });
      })();
    </script>
  </body>
</html>
